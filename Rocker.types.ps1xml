<!-- Generated with EZOut 2.0.5: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>docker.help</Name>
    <Members>
      <ScriptMethod>
        <Name>Parse</Name>
        <Script>
                        [ValidatePattern("^(?&gt;docker(?&gt;-|\s)compose)?\s{1,}help|usage:)")]
param(
[Parameter(ValueFromPipeline)]
[string]
$Content,

[string]
$CommandLine
)

begin {
    $dockerCommandPattern = '^\s{2}(?&lt;CmdName&gt;\w+)(?&lt;IsPlugin&gt;\*)?\s+(?&lt;Description&gt;.+$)'    
    $DockerOptionsPattern = '\s{2,}(?:\-{1,2}\w+)'
    
    $CurrentOutput = $null
    
    $DockerCommandHelp = [PSCustomObject][Ordered]@{
                                 PSTypeName  = 'Docker.Help'
                                 CommandLine = $CommandLine
                                 Usage       = ''
                                 Description = ''
                                 Options     = @()
                                 Commands    = @()            
                             }

    $inOptions  = $false
    $inCommands = $false
}

process {
    foreach ($line in $content -split '[\r\n]+') {
        if (($line -match '^Usage\:') -and (-not $DockerCommandHelp.Usage)) {
            $DockerCommandHelp.Usage = $line -replace '^Usage\:\s{0,}'
        }
        elseif ($line -match '^\S+' -and $line -notmatch '^.+?\:$') {
            if (-not $DockerCommandHelp.Description) {
                $DockerCommandHelp.Description = $line
            } else {
                $DockerCommandHelp.Description += ([Environment]::NewLine + $line)
            }            
        }
        if ($line -match $DockerOptionsPattern) {
            if ($CurrentOutput) {
                $DockerCommandHelp.Options += $CurrentOutput
            }
            $inOptions = $true
            if ($line -match '--[\w\-]+\s(?&lt;type&gt;\S+)') {
                $CurrentOutput = 
                    [PSCustomObject][Ordered]@{
                                            PSTypeName = 'Docker.Argument'
                                            OptionName = $(@($line -split '\s' -match '^-{2}')[0]) -as [string]
                                            OptionFlag = $line -split '\s' -match '^-\w' -replace '\,\s{,0}$'
                                            Type = $matches.type
                                            CommandLine = $CommandLine
                                            Description = @($line -split '\s{2,}')[-1]
                                        }
            } else {
                $CurrentOutput =
                    [PSCustomObject][Ordered]@{
                                            PSTypeName = 'Docker.Argument'
                                            OptionName = $(@($line -split '\s' -match '^-{2}')[0]) -as [string]
                                            OptionFlag = $line -split '\s' -match '^-\w' -replace '\,\s{,0}$'
                                            CommandLine = $CommandLine
                                            Description = @($line -split '\s{2,}')[-1]
                                        }
            }
            
            
        }
        elseif ($line -match $dockerCommandPattern) {
            $inCommands = $true
            if ($matches.CmdName -eq 'docker') { continue }

            if ($CurrentOutput) {
                if ($CurrentOutput.OptionName) {
                    $DockerCommandHelp.Options += $CurrentOutput
                } else {
                    $DockerCommandHelp.Commands += $CurrentOutput
                }
                
            }
            $CurrentOutput = 
                [PSCustomObject][Ordered]@{
                                    PSTypeName = 'Docker.Command'
                                    CommandName = $matches.CmdName
                                    Description = $matches.Description
                                    IsPlugin = $matches.IsPlugin -as [bool]
                                }
            if ($CurrentOutput.CommandName -match '^\s{0,}$') {
                $CurrentOutput = $null
            }
        }
        elseif ($line -match '^\s{8,}' -and $CurrentOutput) {
            $CurrentOutput.Description += ($line -replace '^\s{8,}', ' ')
        }
    }
}

end {
    if ($CurrentOutput) {
        if ($CurrentOutput.CommandName) {
            $DockerCommandHelp.Commands += $CurrentOutput
        } else {
            $DockerCommandHelp.Options += $CurrentOutput
        }        
    }
    $DockerCommandHelp
}

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>Rocker</Name>
    <Members>
      <ScriptProperty>
        <Name>Parsers</Name>
        <GetScriptBlock>
                        $Wildcard = '?*ocker*'
$Pattern  = 'Parse'
$TypeName = 'Rocker.Parser'
$CollectionTypeName = 'Rocker.Parsers'


$Collection = [Ordered]@{PSTypeName=$CollectionTypeName}

@(
    foreach ($typeData in Get-TypeData -TypeName $Wildcard) {
        $potentialParsers = @($typeData.Members.Keys -match $Pattern)
        foreach ($potentialParser in $typeData.Members[$potentialParsers]) {
            if ($potentialParser -is [management.automation.runspaces.ScriptMethodData]) {
                $parserFullName = "$($typeData.TypeName).$($potentialParser.Name)"
                $Collection[$parserFullName] = $potentialParser | 
                    Add-Member NoteProperty TypeName $typeData.TypeName -Force -PassThru |
                    Add-Member NoteProperty Name $parserFullName -Force -PassThru
                $Collection[$parserFullName].pstypenames.add($TypeName)
            }
        }
    }

    $foundCommands = @($ExecutionContext.SessionState.InvokeCommand.GetCommands($Wildcard, 'Alias,Function,Cmdlet', $true) -match $Pattern)
    if ($foundCommands) {
        foreach ($commandFound in $foundCommands) {
            if (-not $commandFound.Name) { continue }
            $Collection[$commandFound.Name] = $commandFound
            $Collection[$commandFound.Name].pstypenames.add($TypeName)
        }
    }
        
)

[PSCustomObject]$Collection
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>Rocker.Parser</Name>
    <Members>
      <ScriptMethod>
        <Name>Validate</Name>
        <Script>
                        param(
[PSObject]
$Argument
)

$ThisScriptBlock = if ($this.Script) {
    $this.Script
} elseif ($this.ScriptBlock) {
    $this.ScriptBlock
}

$validationAttributes =
    foreach ($attribute in $ThisScriptBlock.Attributes) {
        if ($attribute -is [ValidateScript]) {
            $attribute
        }
        if ($attribute -is [ValidatePattern]) {
            $attribute
        }
    }

if (-not $validationAttributes) { return $true}

:SomethingIsValid do {

    foreach ($attribute in $validationAttributes) {
        if ($attribute -is [ValidateScript]) {
            $this = $_ = $Argument
            $isValid = &amp; $attribute.ScriptBlock $this
            if ($isValid) {
                break SomethingIsValid
            }
        }
        if ($attribute -is [ValidatePattern]) {
            if (
                [Regex]::new($attribute.RegexPattern, $attribute.Options, "00:00:00.1").IsMatch("$Argument")
            ) {
                break SomethingIsValid
            }
        }
    }

    return $false 


} while ($false)

return $true

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>Rocker.Parsers</Name>
    <Members>
      <ScriptMethod>
        <Name>ForCommand</Name>
        <Script>
                        param(
$CommandLine
)

foreach ($parser in $this.All) {
    if ($parser.Validate -and $parser.Validate($commandLine)) {
        $parser
    }    
}
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>All</Name>
        <GetScriptBlock>
                        @(foreach ($property in $this.psobject.properties) {
    if (-not $property.IsInstance) { continue } 
    if (-not $property -is [psnoteproperty]) { continue } 
    $property.Value
})

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>